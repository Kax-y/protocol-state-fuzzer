@startuml Abstracting IO from AbstractInput/Output

class AbstractParameterizedSymbol extends ParameterizedSymbol implements AbstractSymbol {
    IOHandler: IOHandler
    --
    ?
}

abstract class IOHandler {
    extendedWait: Long
    --
    getExtendedWait(): Long
    setExtendedWait(extendedWait: Long): void
    isEnabled(context: ExecutionContext): boolean
    preSendUpdate(context: ExecutionContext): void
    generateProtocolMessage(context: ExecutionContext): \nProtocolMessage
    postSendUpdate(context: ExecutionContext): void
    postReceiveUpdate(output: AbstractOutput, \nabstractOutputChecker: AbstractOutputChecker, context: \nExecutionContext): void
    --
    MESSAGE_SEPARATOR: String
    REPEATING_INDICATOR: String
    TIMEOUT: String
    UNKNOWN_MESSAGE: String
    SOCKET_CLOSED: String
    DISABLED: String
    --
    timeout(): AbstractOutput
    unknown(): AbstractOutput
    socketClosed(): AbstractOutput
    disabled(): AbstractOutput
    isComposite(): boolean
    isAtomic(): boolean
    isRepeating(): boolean
    getRepeatedOutput(): AbstractOutput
    isTimeout(): boolean
    isSocketClosed(): boolean
    isDisabled(): boolean
    isRecordResponse(): boolean
    hasMessages(): boolean
    getAtomicOutputs(): List<AbstractOutput>
    getAtomicOutputs(unrollRepeating: int): List<AbstractOutput>
    getAtomicAbstractionStrings(): List<String>
    getAtomicAbstractionStrings(unrollRepeating: int): List<String>
}

note top of ParameterizedSymbol : Note that this is from RALib.
abstract class ParameterizedSymbol {
    name: String
    ptypes: DataType[]

    ParameterizedSymbol(name: String, ptypes: DataType...): void
    hashCode(): int
    equals(obj: Object): boolean
    toString(): String
    getName(): String
    getArity(): int
    getPtypes(): DataType[]
}

class OutputSymbol extends ParameterizedSymbol {
    OutputSymbol(name: String, ptypes: DataType...)
    toString(): String
}

class InputSymbol extends ParameterizedSymbol {
    InputSymbol(name: String, ptypes: DataType...)
    toString(): String
}

interface AbstractSymbol {
    name: String
    isInput: boolean
    
    AbstractSymbol(isInput: boolean): void
    AbstractSymbol(name: string, isInput: boolean): void
    getName(): String
    setName(name: String): void
    getIsInput(): boolean
    inputDistinguishingName(): String
    toString(): String
}

abstract class AbstractInput extends AbstractSymbol {
    IOHandler: IOHandler
    
    AbstractInput(): void
    AbstractInput(name: String): void
    getPreferredMapper(sulConfig: SulConfig): Mapper
    getInputType(): Enum<?>
}

abstract class AbstractOutput extends AbstractSymbol {
    specialOutputsMap: Map<String, AbstractOutput>
    messages: List<ProtocolMessage>
    alive: boolean
    IOHandler: IOHandler

    getSpecialOutput(symbolName: String): AbstractOutput
    AbstractOutput(): void
    AbstractOutput(name: String): void
    AbstractOutput(name: String, messages: List<ProtocolMessage>)
    toDetailedString(): String
    getMessages(): List<ProtocolMessage>
    equals(o: Object): boolean
    hashCode(): int
    isAlive(): boolean
    setAlive(): void
    buildContentInfo(): String
}

interface AlphabetBuilder {
    DEFAULT_ALPHABET_NO_EXTENSION: String
    
    build(alphabetProvider: AlphabetProvider): Alphabet<AbstractInput>
    getAlphabetFileInputStream(alphabetProvider: AlphabetProvider): InputStream
    getAlphabetFileExtension(): String
    exportAlphabetToFile(outputFileName: String, alphabet: Alphabet<AbstractInput>): void
}

AlphabetBuilder <-- AbstractInput
IOHandler -- AbstractOutput
IOHandler -- AbstractInput
IOHandler -- AbstractParameterizedSymbol
@enduml