@startuml PSF
skinparam style strictuml
skinparam maxMessageSize 100

interface StateFuzzer {
    LEARNED_MODEL_FILENAME: String
    STATISTICS_FILENAME: String
    MAPPER_CONNECTION_CONFIG_FILENAME: String
    ALPHABET_FILENAME_NO_EXTENSION: String
    ERROR_FILENAME: String
    LEARNED_MODEL_FILENAME: String

    startFuzzing(): LearnerResult
}

class StateFuzzerRA implements StateFuzzer {
    LOGGER: Logger

    startFuzzing(): LearnerResult
    
}

class StateFuzzerStandard implements StateFuzzer {
    LOGGER: Logger
    ALPHABET_FILENAME: String
    stateFuzzerComposer: StateFuzzerComposer
    alphabet: Alphabet<AbstractInput>
    outputDir: File
    cleanupTasks: CleanupTasks
    stateFuzzerEnabler: StateFuzzerEnabler

    StateFuzzerStandard(stateFuzzerComposer: StateFuzzerComposer)
    startFuzzing(): LearnerResult
    inferStateMachine(): LearnerResult
    copyInputsToOutputDir(outputDir: File): void
    writeToFile(inputStream: InputStream, outputFile: File): void
    roundLimitToInt(roundLimit: Integer): int
    exportHypothesis(hypothesis: StateMachine, destination: File): void
}

interface StateFuzzerComposer {
    NON_DET_FILENAME: String
    QUERY_FILENAME: String

    getStatisticsTracker: StatisticsTracker
    getLearner(): LearningAlgorithm.MealyLearner<AbstractInput, \nAbstractOutput>
    getEquivalenceOracle(): EquivalenceOracle<MealyMachine<?, \nAbstractInput, ?, AbstractOutput>, AbstractInput, \nWord<AbstractOutput>>
    getAlphabet(): Alphabet<AbstractInput>
    getAlphabetFileInputStream(): InputStream
    getAlphabetFileExtension(): String
    getStateFuzzerEnabler(): StateFuzzerEnabler
    getOutputDir(): File
    getCleanupTasks(): CleanupTasks
}

class CommandLineParser {
    LOGGER: Logger
    CMD_STATE_FUZZER_CLIENT: String
    CMD_STATE_FUZZER_SERVER: String
    ARGS_FILE: String
    programName: String
    stateFuzzerConfigBuilder: StateFuzzerConfigBuilder
    stateFuzzerBuilder: StateFuzzerBuilder
    testRunnerBuilder: TestRunnerBuilder
    timingProbeBuilder: TimingProbeBuilder
    externalParentLoggers: String[]

    getBasePackageName(): String
    CommandLineParser(stateFuzzerConfigBuilder: \nStateFuzzerConfigBuilder, stateFuzzerBuilder: StateFuzzerBuilder,\ntestRunnerBuilder: TestRunnerBuilder, timingProbeBuilder: \nTimingProbeBuilder): void
    setProgramName(programName: String): void
    setExternalParentLoggers(externalParentLoggers: String[]): void
    parse(args: String[], exportToPDF: boolean, consumers: \nList<Consumer<LearnerResult>>): List<LearnerResult>
    parse(args: String[], exportToPDF: boolean): List<LearnerResult>
    parse(args: String[]): List<LearnerResult>
    parseAndExecuteCommand(args: String[]): LearnerResult
    parseCommand(args: String[]): ParseResult
    executeCommand(parseResult: ParseResult): LearnerResult
    buildCommander(parseOnlyDynamicParameters: boolean, \nstateFuzzerClientConfig: StateFuzzerClientConfig, \nstateFuzzerServerConfig: StateFuzzerServerConfig): JCommander
    updateLoggingLevel(externalParentLoggers: String[], level: Level)
    prepareOutputDir(args: String[], outDir: String): void
    copyArgsToOutDir(args: String[], outDir: String): void
    ParseResult: ParseResult
}

class ParseResult {
    args: String[]
    commander: JCommander

    ParseResult(args: String[], commander: JCommander): void
    getArgs(): String[]
    getCommander(): JCommander
    isValid(): boolean
    getObjectFromParsedCommand(): Object
    getObjectFromParsedCommand(index: int): Object
}

abstract class AbstractStateMachine {
    LOGGER: Logger
    -alphabet: Alphabet<?>
    +getAlphabet(): Alphabet<?>
    +export(graphFile: File): void
    +Copy(): AbstractStateMachine
    toString(): String
}

class StateMachine extends AbstractStateMachine {
    LOGGER: Logger
    mealyMachine: MealyMachine<?, AbstractInput, ?, AbstractOutput>
    alphabet: Alphabet<AbstractInput>

    StateMachine(mealyMachine: MealyMachine<?, AbstractInput, ?, \nAbstractOutput>, alphabet: Alphabet<AbstractInput>)
    getMealyMachine(): MealyMachine<?, AbstractInput, ?, \nAbstractOutput>
    getAlphabet(): Alphabet<AbstractInput>
    export(graphFile: File): void
    copy(): StateMachine
    toString(): String
}

class RAStateMachine extends AbstractStateMachine {
    -alphabet: Alphabet<ParameterizedSymbol>
    +getAlphabet(): Alphabet<ParameterizedSymbol>
    export(graphFile: File): void
    copy(): RAStateMachine
    toString(): String
    RAStateMachine(automata: RegisterAutomata, alphabet: Alphabet<ParameterizedSymbol>)
    getRAStateMachine(): RegisterAutomata
}

class LearnerResult {
    hypotheses: List<StateMachine>
    learnedModel: StateMachine
    learnedModelFile: File
    statistics: Statistics
    stateFuzzerEnabler: StateFuzzerEnabler

    LearnerResult(): void
    toEmpty(): LearnerResult
    isEmpty(): boolean
    toNormal(): LearnerResult
    addHypothesis(hypothesis: StateMachine): void
    getHypotheses(): List<StateMachine>
    getLearnedModel(): StateMachine
    setLearnedModel(learnedModel: StateMachine): void
    getLearnedModelFile(): File
    setLearnedModelFile(learnedModelFile: File): void
    getStatistics(): Statistics
    setStatistics(statistics: Statistics): void
    getStateFuzzerEnabler(): StateFuzzerEnabler
    setStateFuzzerEnabler(stateFuzzerEnabler: StateFuzzerEnabler): void
}

note top of ParameterizedSymbol : Note that this is from RALib.
abstract class ParameterizedSymbol {
    name: String
    ptypes: DataType[]

    ParameterizedSymbol(name: String, ptypes: DataType...): void
    hashCode(): int
    equals(obj: Object): boolean
    toString(): String
    getName(): String
    getArity(): int
    getPtypes(): DataType[]
}

class OutputSymbol extends ParameterizedSymbol {
    OutputSymbol(name: String, ptypes: DataType...)
    toString(): String
}

class InputSymbol extends ParameterizedSymbol {
    InputSymbol(name: String, ptypes: DataType...)
    toString(): String
}

abstract class AbstractSymbol {
    name: String
    isInput: boolean
    
    AbstractSymbol(isInput: boolean): void
    AbstractSymbol(name: string, isInput: boolean): void
    getName(): String
    setName(name: String): void
    getIsInput(): boolean
    inputDistinguishingName(): String
    toString(): String
}

interface StateFuzzerEnabler {
    getLearnerConfig(): LearnerConfig
    getSulConfig(): SulConfig
    isFuzzingClient(): boolean
    getOutputDir(): String
}

interface StateFuzzerBuilder {
    build(stateFuzzerEnabler: StateFuzzerEnabler): StateFuzzer
}

abstract class AbstractInput extends AbstractSymbol {
    extendedWait: Long

    AbstractInput(): void
    AbstractInput(name: String): void
    getExtendedWait(): Long
    setExtendedWait(extendedWait: Long): void
    getPreferredMapper(sulConfig: SulConfig): Mapper
    isEnabled(context: ExecutionContext): boolean
    preSendUpdate(context: ExecutionContext): void
    generateProtocolMessage(context: ExecutionContext): \nProtocolMessage
    postSendUpdate(context: ExecutionContext): void
    postReceiveUpdate(output: AbstractOutput, \nabstractOutputChecker: AbstractOutputChecker, context: \nExecutionContext): void
    getInputType(): Enum<?>
}

abstract class AbstractOutput extends AbstractSymbol {
    MESSAGE_SEPARATOR: String
    REPEATING_INDICATOR: String
    TIMEOUT: String
    UNKNOWN_MESSAGE: String
    SOCKET_CLOSED: String
    DISABLED: String
    specialOutputsMap: Map<String, AbstractOutput>
    alive: boolean
    messages: List<ProtocolMessage>

    timeout(): AbstractOutput
    unknown(): AbstractOutput
    socketClosed(): AbstractOutput
    disabled(): AbstractOutput
    getSpecialOutput(symbolName: String): AbstractOutput
    AbstractOutput(): void
    AbstractOutput(name: String): void
    AbstractOutput(name: String, messages: List<ProtocolMessage>)
    isComposite(): boolean
    isAtomic(): boolean
    isRepeating(): boolean
    getRepeatedOutput(): AbstractOutput
    isTimeout(): boolean
    isSocketClosed(): boolean
    isDisabled(): boolean
    isRecordResponse(): boolean
    hasMessages(): boolean
    getAtomicOutputs(): List<AbstractOutput>
    getAtomicOutputs(unrollRepeating: int): List<AbstractOutput>
    getAtomicAbstractionStrings(): List<String>
    getAtomicAbstractionStrings(unrollRepeating: int): List<String>
    toDetailedString(): String
    buildContentInfo(): String
    getMessages(): List<ProtocolMessage>
    isAlive(): boolean
    setAlive(): void
    equals(o: Object): boolean
    hashCode(): int
}

interface AlphabetBuilder {
    DEFAULT_ALPHABET_NO_EXTENSION: String
    
    build(alphabetProvider: AlphabetProvider): Alphabet<AbstractInput>
    getAlphabetFileInputStream(alphabetProvider: AlphabetProvider): InputStream
    getAlphabetFileExtension(): String
    exportAlphabetToFile(outputFileName: String, alphabet: Alphabet<AbstractInput>): void
}

CommandLineParser *-- ParseResult : contains
CommandLineParser <-- StateFuzzerBuilder
StateFuzzerBuilder <-- StateFuzzerEnabler
StateFuzzerBuilder <-- StateFuzzer
StateFuzzer <-- LearnerResult
LearnerResult <-- AbstractStateMachine
AlphabetBuilder <-- AbstractInput
StateFuzzerStandard <-- StateFuzzerComposer

@enduml